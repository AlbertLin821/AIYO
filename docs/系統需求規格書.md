# 系統需求規格書 (System Requirements Specification, SRS)

**文件版本**：1.0  
**建立日期**：2026-02-14  
**適用專案**：AIYO 愛遊互動式旅遊網站

---

## 1. 文件目的

本文件從技術角度描述 AIYO 愛遊系統的架構設計、技術實作與系統需求，作為開發團隊的技術指南。

---

## 2. 系統整體架構

### 2.1 高階架構圖

```
[ 前端 ] Next.js + React + TS + Tailwind
   |
   |  REST / WebSocket
   v
[ API Gateway ] Node.js + Express
   |
   |  gRPC / HTTP
   v
[ AI Service ] Python + FastAPI + vLLM(Qwen3-8B)
   |
   |  DB / Cache / External APIs
   v
[ PostgreSQL + pgvector ]   [ Redis ]   [ YouTube API / Maps API / Whisper ]
```

### 2.2 技術棧說明

#### 前端層

- **框架**：Next.js 14 App Router
  - 支援 SSR/ISR，適合 SEO（旅遊關鍵字搜尋）
- **UI 技術**：
  - React + TypeScript + Tailwind CSS
  - shadcn/ui 元件庫
  - 打造 Chat UI、片段卡片、拖拉行程
- **語音輸入**：
  - Web Speech API 支援語音輸入

#### 後端 API Gateway

- **技術**：Node.js + Express + Prisma ORM
- **功能**：
  - 管理使用者、會話、行程 CRUD
  - 對接 Python FastAPI 的 AI 服務
- **即時通訊**：
  - WebSocket（socket.io）
  - 串流 AI 回覆及即時更新行程/地圖

#### AI Service

- **技術**：Python + FastAPI 作為 Orchestrator
- **模型部署**：
  - 對接 vLLM / Ollama 提供 Qwen3-8B / Llama3.3-8B 模型
- **核心模組**：
  - Tool-usage / Recommendation / Planning / Memory
- **功能**：
  - 影片語音轉文字（Whisper）
  - 字幕分段與 Embedding
  - RAG 檢索片段
  - LLM 對話、行程規劃、工具呼叫

#### 資料庫與快取

- **PostgreSQL**：
  - 基本資料與結構化資料
- **pgvector**：
  - 儲存影片片段的語意向量與景點向量
- **Redis**：
  - Session / 最近上下文的快取

#### 外部 API

- **YouTube Data API v3**：
  - 搜尋旅遊影片、取得影片 metadata
- **YouTube Captions API**：
  - 取得字幕（若有）
- **Whisper API（或自架 Whisper）**：
  - 沒有字幕時使用
- **Google Maps Places / Directions / Distance Matrix**：
  - 取得景點地理資訊與交通時間

---

## 3. 影片索引與片段切割（Semantic Video Segmentation）

### 3.1 資料流程總覽

影片索引與片段切割的完整流程如下：

1. 蒐集影片
2. 取得字幕
3. 字幕前處理
4. Embedding
5. 語意分段（Semantic Segmentation）
6. 景點實體抽取（NER + LLM）
7. 寫入資料庫
8. 向量索引（pgvector）

### 3.2 詳細實作步驟

#### 步驟 1：蒐集影片

**使用 YouTube Data API `search.list`**：

- **關鍵字範例**：
  - 「台灣 旅遊 vlog」
  - 「台南 兩天一夜」
  - 「花東 公路旅遊」
- **搜尋條件**：
  - `type=video`
  - `videoDuration=medium/long`
  - `regionCode=TW`
  - `relevanceLanguage=zh-Hant`

**資料儲存**：

儲存到 `videos` 表，欄位包括：
- `id, youtube_id, title, channel, duration, view_count, like_count, ...`

#### 步驟 2：取得字幕

**優先使用 YouTube Captions API**：

- `captions.list` 找可用字幕
- `captions.download` 取得 SRT/VTT 格式

**若無字幕**：

- 使用 Whisper API：
  1. 先用 `youtube-dl` 或類似工具抓音訊
  2. Whisper 轉文字與時間戳

#### 步驟 3：字幕前處理

**整理字幕序列**：

- 格式：`[(start_time, end_time, text), ...]`
- 做斷詞、移除停用詞（可使用 jieba / spaCy）

#### 步驟 4：Embedding

**對每句 `text` 用 Embedding 模型**：

- **選項**：
  - sentence-transformers（如 `paraphrase-multilingual-MiniLM-L12-v2`）
  - OpenAI Embedding（如 `text-embedding-3-large`，若仍使用部分 OpenAI）
  - 本地 Embedding 模型（可搭配 Ollama 之外的 embedding 模型）

**輸出**：得到向量序列 `e1, e2, ..., en`

#### 步驟 5：語意分段（Semantic Segmentation）

**演算法概念**（參考 Google Semantic Video Trailers）：

1. **相似度計算**：
   - 依時間順序走過字幕
   - 計算 `cosine_similarity(e_i, e_{i+1})`
   - 若相似度低於閾值（例如 0.6–0.7），且時間間隔大於 N 秒，則判定可以切段

2. **Heuristic 規則**：
   - 字幕出現與結束
   - 音樂段落變化
   - 可參考音樂 break 分段的研究

**輸出**：得到一組片段，每個片段包含：
- 一串字幕
- 起訖時間

#### 步驟 6：景點實體抽取（NER + LLM）

**對每個片段的所有字幕文本**：

1. **先用字典/正則比對**：
   - 常見景點清單
   - 地名、餐廳名、住宿名等

2. **再用 LLM 補強**：
   - Prompt 範例：
    ```
    請從以下旅遊影片字幕中抽取「景點名稱」與「簡短介紹」，
    輸出 JSON 陣列，格式為：
    [{ "name": "...", "description": "...", "type": "景點/餐廳/住宿" }]
    ```

#### 步驟 7：寫入資料庫

**資料表結構**：

1. **`videos`**：影片基本資料
2. **`segments`**：
   - `id, video_id, start_sec, end_sec, transcript, summary, embedding_vector`
3. **`places`**：
   - `id, name, address, lat, lng, category, description, embedding_vector`
4. **`segment_places`**（關聯表）：
   - `segment_id, place_id`

#### 步驟 8：向量索引（pgvector）

**建立索引**：

```sql
CREATE INDEX ON segments USING ivfflat (embedding_vector vector_cosine_ops);
```

**查詢範例**：

```sql
SELECT * FROM segments
ORDER BY embedding_vector <-> :query_vector
LIMIT 10;
```

---

## 4. 對話系統與 RAG（Retrieval-Augmented Generation）

### 4.1 對話流程設計

**完整流程**：

1. **使用者送出訊息**（語音或文字）
2. **API Gateway**：
   - 從 Redis 讀取該 `session` 最近 N 則訊息作為 context
3. **傳給 AI Service**：
   - 將 message + context 傳給 FastAPI
4. **AI Service 呼叫 vLLM**：
   - 使用 Tool-calling 模式：
     - **Tool 1**：`search_segments(query)` → 在 pgvector 查相關片段
     - **Tool 2**：`plan_itinerary(segments, days, preferences)` → 行程排程
5. **AI 生成回應**：
   - 自然語言回覆（給聊天介面）
   - 結構化 JSON：片段列表、行程 JSON（給前端渲染）

### 4.2 RAG 具體步驟

**範例查詢**：「幫我找台南小吃相關影片片段」

#### 步驟 1：Query Embedding

- 把整句 query 經過同一個 Embedding 模型轉成向量 `q`

#### 步驟 2：向量搜尋（pgvector）

**SQL 查詢**：

```sql
SELECT * FROM segments
WHERE city = '台南'
ORDER BY embedding_vector <-> :q
LIMIT 10;
```

#### 步驟 3：LLM 整理結果

- 將 retrieve 出來的 segments（包含 transcript、summary、place info）傳給 LLM
- 要求：
  - 整理成 3–5 個最推薦的片段
  - 產生 user-friendly 的介紹文字＋片段標題

#### 步驟 4：回傳前端

**JSON 格式**：

```json
{
  "reply": "幫你找到這幾個台南小吃的影片片段...",
  "segments": [
    {
      "videoId": "...",
      "start": 45,
      "end": 140,
      "placeNames": ["花園夜市"],
      "summary": "夜市小吃巡禮..."
    }
  ],
  "itinerary": null
}
```

---

## 5. 行程規劃與地圖整合

### 5.1 景點地理資訊

**使用 Google Maps Places API**：

- 根據景點名稱與城市查座標
- 儲存 `lat/lng` 到 `places` 表

### 5.2 路線與時間估算

**使用 Distance Matrix API 或 Directions API**：

- **輸入**：一串景點座標
- **輸出**：旅程時間、距離

### 5.3 行程規劃邏輯

**兩階段規劃**：

1. **LLM Planner**：
   - 產生初步行程草稿（根據較高層的偏好）

2. **後端程式微調**：
   - 根據開放時間與距離作微調
   - 類似 TMS-Net 等研究中提到的時間序列優化概念

**產出格式**：

```json
{
  "days": [
    {
      "date": "Day1",
      "slots": [
        {
          "timeRange": "09:00-11:00",
          "place": "安平古堡",
          "fromSegmentId": 123
        },
        {
          "timeRange": "11:30-13:00",
          "place": "安平老街美食",
          "fromSegmentId": 124
        }
      ]
    }
  ]
}
```

---

## 6. 資料庫設計

### 6.1 核心資料表

#### videos（影片表）

```sql
CREATE TABLE videos (
  id SERIAL PRIMARY KEY,
  youtube_id VARCHAR(20) UNIQUE NOT NULL,
  title TEXT NOT NULL,
  channel VARCHAR(255),
  duration INTEGER,
  view_count BIGINT,
  like_count BIGINT,
  created_at TIMESTAMP DEFAULT NOW(),
  updated_at TIMESTAMP DEFAULT NOW()
);
```

#### segments（片段表）

```sql
CREATE TABLE segments (
  id SERIAL PRIMARY KEY,
  video_id INTEGER REFERENCES videos(id),
  start_sec INTEGER NOT NULL,
  end_sec INTEGER NOT NULL,
  transcript TEXT,
  summary TEXT,
  embedding_vector vector(384),
  created_at TIMESTAMP DEFAULT NOW()
);
```

#### places（景點表）

```sql
CREATE TABLE places (
  id SERIAL PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  address TEXT,
  lat DECIMAL(10, 8),
  lng DECIMAL(11, 8),
  category VARCHAR(50),
  description TEXT,
  embedding_vector vector(384),
  created_at TIMESTAMP DEFAULT NOW()
);
```

#### segment_places（片段-景點關聯表）

```sql
CREATE TABLE segment_places (
  segment_id INTEGER REFERENCES segments(id),
  place_id INTEGER REFERENCES places(id),
  PRIMARY KEY (segment_id, place_id)
);
```

### 6.2 索引設計

- **向量索引**：使用 pgvector 的 ivfflat 索引
- **一般索引**：在 `videos.youtube_id`, `places.name` 等欄位建立索引

---

## 7. API 設計

### 7.1 RESTful API 端點

#### 對話相關

- `POST /api/chat` - 發送訊息並獲得 AI 回應
- `GET /api/chat/history/:sessionId` - 取得對話歷史
- `DELETE /api/chat/history/:sessionId` - 清除對話歷史

#### 影片與片段相關

- `GET /api/videos` - 搜尋影片
- `GET /api/videos/:id/segments` - 取得影片片段列表
- `GET /api/segments/:id` - 取得片段詳情

#### 行程相關

- `POST /api/itinerary` - 建立行程
- `GET /api/itinerary/:id` - 取得行程詳情
- `PUT /api/itinerary/:id` - 更新行程
- `DELETE /api/itinerary/:id` - 刪除行程

### 7.2 WebSocket 事件

- `message` - 發送訊息
- `stream_response` - 串流 AI 回應
- `itinerary_update` - 行程更新通知

---

## 8. 安全性需求

### 8.1 資料安全

- 使用者資料加密儲存
- API 使用 HTTPS
- 敏感資訊（API Key）使用環境變數

### 8.2 存取控制

- Session 管理
- Rate limiting 防止濫用
- CORS 設定

---

## 9. 效能需求

### 9.1 回應時間

- 語音轉文字：< 2 秒
- AI 對話回應：< 5 秒
- 影片片段載入：< 3 秒
- 行程規劃：< 10 秒

### 9.2 併發處理

- 支援至少 100 個同時線上使用者
- 使用 Redis 快取降低資料庫負載

---

## 10. 參考文件

- [使用者需求規格書.md](./使用者需求規格書.md) - 使用者需求
- [技術實作指南.md](./技術實作指南.md) - LLM 部署細節
- [開發路線圖.md](./開發路線圖.md) - 開發時程
